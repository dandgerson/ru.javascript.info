
# Асинхронные итераторы и генераторы

Асинхронные итераторы позволяют перебирать данные по-мере их поступления, "по запросу".

Например, когда мы скачиваем, что-нибудь пакет-за-пакетом, или просто ожидаем потока асинхронных событий и хотим их перебирать -- асинхронные итераторы и генераторы могут очень пригодиться. Давайте сначала рассмотрим простой пример, чтобы познакомиться с синтаксисом, а затем перейдём уже к реальным случаям их применения.

## Асинхронные итераторы

Асинхронные итераторы почти идентичны обычным итераторам с учётом нескольких синтаксических отличий.

"Обычный" итерируемый объект из главы <info:iterable> выглядит так:

```js run
let range = {
  from: 1,
  to: 5,

  // цикл for..of вызывает этот метод один раз в самом начале
*!*
  [Symbol.iterator]() {
*/!*
    // ...он возвращает итератор:
    // далее, for..of работает только с ним, запрашивая этот объект для последующих значений
    return {
      current: this.from,
      last: this.to,

      // next() вызывается на каждой итерации цикла for..of
*!*
      next() { // (2)
        // метод должен вернуть значение в виде объекта {done:.., value :...}
*/!*
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for(let value of range) {
  alert(value); // 1, затем 2, затем 3, затем 4, затем 5
}
```

Если есть необходимость, можете вернуться к [главе об итерируемых объектах](info:iterable), чтобы освежить детали об обычных итераторах.

Чтобы объект перебирался асинхронно:
1. Нам понадобится `Symbol.asyncIterator` вместо `Symbol.iterator`.
2. Метод `next()` должен возвращать промис.
3. Чтобы перебрать такой объект, мы должны запустить цикл `for await (let item of iterable)`.

Давайте сделаем объект `range` итерируемым, как в примере выше, но на этот раз, объект будет возвращать значения асинхронно, один раз в секунду:

```js run
let range = {
  from: 1,
  to: 5,

  // цикл for await..of вызвает этот метод один раз в самом начале
*!*
  [Symbol.asyncIterator]() { // (1)
*/!*
    // ...метод возвращает итератор:
    // далее, цикл for await..of работает только с ним, запрашивая этот объект для последующих значений
    return {
      current: this.from,
      last: this.to,

      // Метод next() вызывается на каждой итерации цикла for..of
*!*
      async next() { // (2)
        // метод должен возвращать значение в виде объекта {done:.., value :...}
        // (автоматически оборачивая его в промис с помощью async)
*/!*

        // можно использовать await внутри, выполняя асинхронные задачи:
        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {

*!*
  for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
  }
*/!*

})()
```

Как видно, все компоненты похожи, как в случае с обычными итераторами:

1. Для того, чтобы сделать объект перебираемым асинхронно, у него должен быть метод `Symbol.asyncIterator` `(1)`.
2. Он должен возвращать объект с методом `next()`, возвращающим промис `(2)`.
3. Метод `next()` не обязательно должен быть `async`, он может быть и обычным методом, возвращающим промис, но `async` позволяет использовать внутри себя `await`. Тут мы просто выжидаем одну секунду `(3)`.
4. Для перебора, используется цикл `for await(let value of range)` `(4)`, а именно - добавляется "await" после "for". Он вызывает `range[Symbol.asyncIterator]()` один раз, и затем метод `next()` для каждого значения.

Вот небольшая шпаргалка:

|       | Обычные итераторы | Асинхронные итераторы |
|-------|-----------|-----------------|
| Встроенный метод для перебора | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` возращаемое значение              | любое         | `Promise`  |
| для перебора используется                          | `for..of`         | `for await..of` |


````warn header="Оператор расширения не работает асинхронно"
Не все возможности языка, совместимые с обычными синхронными итераторыми, работают с их асинхронными аналогами.

Например, оператор расширения не будет работать:
```js
alert( [...range] ); // Ошибка, нет свойства Symbol.iterator
```

Это естественно, т.к. оператор расширения ожидает найти свойство `Symbol.iterator`, как и цикл `for..of` без `await`.
````

## Асинхронные генераторы

В JavaScript также есть генераторы, которые тоже являются итерируемыми объектами.

Давайте вернёмся к генераторам из статьи [](info:generators). Они генерируют последовательность значений от `start` до `end` (или каких-либо ещё):

```js run
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1, затем 2, затем 3, затем 4, затем 5
}
```


Это нормально, что мы не можем использовать `await` в генераторах. Все значения должны обрабатываться синхронно: задержкам не место в цикле `for..of`.

Но что, если всё же нам понадобится воспользоваться `await` в теле генератора? Для выполнения сетевых запросов, к примеру.

Нет проблем, просто поставьте `async` перед генератором, вот так:

```js run
*!*async*/!* function* generateSequence(start, end) {

  for (let i = start; i <= end; i++) {

*!*
    // ого, теперь await работает!
    await new Promise(resolve => setTimeout(resolve, 1000));
*/!*

    yield i;
  }

}

(async () => {

  let generator = generateSequence(1, 5);
  for *!*await*/!* (let value of generator) {
    alert(value); // 1, затем 2, затем 3, затем 4, затем 5
  }

})();
```

Теперь у нас есть асинхронные генератор, итерируемый объект с циклом `for await...of`.

В самом деле - это очень просто. Мы добавляем ключевое слово `async`, и теперь внутри генератора можно использовать `await`, промисы и всё остальное, что связано с async-функциями.

Технически, ещё одним отличием асинхронных генераторов, является то, что метод `generator.next()` теперь тоже асинхронный, и возвращает промисы.

Вместо `result = generator.next()` для обычного не асинхронного генератора, значения будут получаться иначе:

```js
result = await generator.next(); // result = {value: ..., done: true/false}
```

## Итерируемые объекты с асинхронными генераторами

Когда мы хотим сделать объект итерируемым, нам нужно добавить ему свойство `Symbol.iterator`.

```js
let range = {
  from: 1,
  to: 5,
*!*
  [Symbol.iterator]() { ...возвращает объект с методом next, делающий range итерируемым...  }
*/!*
}
```

Распространённый приём возвращать из `Symbol.iterator` генератор, вместо простого объекта с методом `next`, как в примере выше.

Давайте возьмём пример из главы [](info:generators):

```js run
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // сокращение для [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1, затем 2, затем 3, затем 4, затем 5
}
```

Представленный объект `range` итерируемый, и генератор `*[Symbol.iterator]` реализует логику для перебора значений.

Для того, чтобы генератор стал асинхронным, нам нужно заменить `Symbol.iterator` на async `Symbol.asyncIterator`:

```js run
let range = {
  from: 1,
  to: 5,

*!*
  async *[Symbol.asyncIterator]() { // то же, что [Symbol.asyncIterator]: async function*()
*/!*
    for(let value = this.from; value <= this.to; value++) {

      // делает паузу между значениями, ожидая чего-либо
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};

(async () => {

  for *!*await*/!* (let value of range) {
    alert(value); // 1, затем 2, затем 3, затем 4, затем 5
  }

})();
```

Теперь значения идут с задержкой в 1 секунду.

## Пример из реальной жизни

Поскольку мы уже изучили простые примеры, давшие понимание основ, давайте разберём случай из реальной жизни.

Есть множество онлайн API, которые предоставляют данные по-странично. Например, когда нам нужен список пользователей, мы можем последовательно подгружать их страница-за-страницей: запрос вернёт заранее известное число (например 100 пользователей), и предоставит URL для следующей страницы.

Подход очень распространённый. Он работает не только со списом пользователей, но с чем-угодно. Например, GitHub позволяет получать коммиты подобным, по-страничным образом:

- Мы должны сделать запрос по URL вида `https://api.github.com/repos/<repo>/commits`.
- Получить ответ в виде JSON с 30-ю коммитами, а также ссылку со следующей страницей в заголовке `Link`.
- Затем мы можем использовать эту ссылку для следующего запроса, чтобы получить ещё коммиты, и так далее.

А что, если мы захотим получить итерируемый источних коммитов, чтобы использовать его следующим образом:

```js
let repo = 'javascript-tutorial/ ru.javascript.info'; // GitHub репозиторий, из которого получаем коммиты

for await (let commit of fetchCommits(repo)) {
  // обработать коммит
}
```

Нам нужно, чтобы `fetchCommits` мог получать коммиты, совершая запросы по-мере необходимости, а также обрабатывал для нас подгрузку всех по-страничных данных, просто перебирая их в цикле `for await..of`.

С асинхронными генераторами это реализовать довольно просто:

```js
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {'User-Agent': 'Our script'}, // github запрашивает заголовок user-agent
    });

    const body = await response.json(); // (2) парсит ответ, как JSON (массив коммитов)

    // (3) URL следующей страницы находится в заголовках, извлечём их
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage && nextPage[1];

    url = nextPage;

    for(let commit of body) { // (4) подгружать коммиты один за одним, пока не кончится страница
      yield commit;
    }
  }
}
```

1. Мы используем встроенный в браузер метод `fetch` для загрузки данных с удалённого URL. Это позволяет обеспечить авторизацию и наличие остальных заголовков, если они потребуются. В данном случае GitHub запрашивает заголовок `User-Agent`.
2. Результат fetch парсится как JSON, с помощью специфичного для `fetch` метода.
3. Из ответа мы можем получить URL следующей страницы из заголовка `Link`. URL имеет особый формат, таким образом, мы можем воспользоваться regexp, чтобы получить его. Ссылка может выглядеть примерно так: `https://api.github.com/repositories/93253246/commits?page=2`, она автоматически генерируется GitHub.
4. Затем мы дожидаемся последовательной подгрузки всех коммитов, и по её завершению -- следующая итерация цикла `while(url)` запустит выполнение ещё одного запроса.

Пример использования (выводит коммиты автора в консоль):

```js run
(async () => {

  let count = 0;

  for await (const commit of fetchCommits('javascript-tutorial/ru.javascript.info')) {

    console.log(commit.author.login);

    if (++count == 100) { // остановится на 100-м коммите
      break;
    }
  }

})();
```

Как раз то, что мы и хотели. Внутренняя механика по-страничной подгрузки данных не видна снаружи. Для нас это просто асинхронный генератор, возвращающий коммиты.

## Итого

Обычные итераторы и генераторы прекрасно работают с данными, генерация которых не требует времени.

Когда мы ожидаем, что данные будут поступать асинхронно, с задержками, могут быть использованы их асинхронные аналоги, и цикл `for await..of` вместо `for..of`.

Синтаксические различия между async и обычными итераторами:

|       | Обычные итераторы | Асинхронные итераторы |
|-------|-----------|-----------------|
| Встроенный метод для перебора | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` возвращаемое значение              | любое         | `Promise`  |

Синтаксические различия между async и обычными генераторами:

|       | Обычные генераторы | Асинхронные генераторы |
|-------|-----------|-----------------|
| Объявление | `function*` | `async function*` |
| `generator.next()` возвращает              | `{value:…, done: true/false}`         | Создаёт успешно выполнившийся `Promise` с результатом `{value:…, done: true/false}`  |

В веб-разработке нам часто встречаются потоки данных, когда они поступают пакет-за-пакетом. Например, скачивание или выгрузка больших файлов.

Для обработки таких данных мы можем воспользоваться асинхронными генераторами, но также существует и другое API называемое Потоками (Streams), оно может быть более удобным, т.к. предоставляет специальный интерфейс для преобразования и передачи данных от одного потока другому (например, загрузка из одного места и моментальная передача куда-нибудь ещё). Это АPI имеет более сложное устройство.

API Потоков не является частью стандарта языка JavaScript. Потоки и асинхронные генераторы хорошо дополняют друг друга. Обе этих технологии прекрасный способ обработки потоков асинхронных данных.
